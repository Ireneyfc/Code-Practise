#### 简介
C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：
- 封装
- 抽象
- 继承
- 多态
  
C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。
- 对象 - 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。
- 类 - 类可以定义为描述对象行为/状态的模板/蓝图。
- 方法 - 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。
- 即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。

#### 编译环境
如果是多个 C++ 代码文件，如 runoob1.cpp、runoob2.cpp，编译命令如下：
```c++
$ g++ runoob1.cpp runoob2.cpp -o runoob
```
#### 程序结构
- ` using namespace std;` 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。
- `cout << "Hello World";`会在屏幕上显示消息 "Hello World"。
#### 注释
```c++
/* 这是注释 */
/* C++ 注释也可以
* 跨行
*/
 // 输出 Hello World
```
#### 数据类型
- 基本类型
  ```
    bool
	char
	int
	float
	double
	void
	wchar_t
    ```
- 一些基本类型可以使用一个或多个类型修饰符进行修饰：
   ``` 
    signed
    unsigned
    short
    long
    ```
- typedef 声明
您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：
```
typedef type newname; 
```
例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：
```
typedef int feet;
```
现在，下面的声明是完全合法的，它创建了一个整型变量 distance：
```
feet distance;
```
- 枚举类型

如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓"枚举"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。

枚举类型的一般形式为：
```c++
enum 枚举名{ 
     标识符[=整型常数], 
     标识符[=整型常数], 
... 
    标识符[=整型常数]
} 枚举变量;
``` 
如果枚举没有初始化, 即省掉"=整型常数"时, 则从第一个标识符开始。

例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 "blue"。
```c++
enum color { red, green, blue } c;
c = blue;
```
默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。
```c++
enum color { red, green=5, blue };
```
在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。
#### C++ 变量作用域
##### 作用域是程序的一个区域，一般来说有三个地方可以定义变量：
- 局部变量：在函数或一个代码块内部声明的变量
- 形式参数: 在函数参数的定义中声明的变量
- 全局变量: 在所有函数外部声明的变量
##### 注意：
- 全局变量的值可以在局部函数内重新赋值。
- 若要想让 main 函数也使用全局变量 a，可以用 extern 对全局变量进行声明，就可以合法使用了。
##### C++ 全局变量、局部变量、静态全局变量、静态局部变量的区别：

C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。

从作用域看：

全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。

静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。

局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。

静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。

从分配内存空间看：

全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。

全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。

 1)、静态变量会被放在程序的静态数据存储区（数据段）(全局可见)中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。
 2)、变量用static告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。
从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。应予以注意。

Tips:

A、若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；
B、若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；
C、设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见；
D、如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带“内部存储器”功能的的函数)
E、函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。

static 全局变量:改变作用范围，不改变存储位置

static 局部变量：改变存储位置，不改变作用范围

静态函数 ：在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。

如果在一个源文件中定义的函数，只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用，这种函数也称为内部函数。定义一个内部函数，只需在函数类型前再加一个“static”关键字即可。
##### C++ “::” 作用域符 双冒号
一、
:: 是作用域符，是运算符中等级最高的，它分为三种:
- global scope(全局作用域符），用法（::name)
- class scope(类作用域符），用法(class::name)
- namespace scope(命名空间作用域符），用法(namespace::name)
他们都是左关联（left-associativity)，他们的作用都是为了更明确的调用你想要的变量:
- 如在程序中的某一处你想调用全局变量a，那么就写成::a；（也可以是全局函数）
- 如果想调用class A中的成员变量a，那么就写成A::a;
- 另外一个如果想调用namespace std中的cout成员，你就写成std::cout（相当于using namespace std；cout）意思是在这里我想用cout对象是命名空间std中的cout（即就是标准库里边的cout）

、
- 作用域符号::的前面一般是类名称，后面一般是该类的成员名称。
C++为例避免不同的类有名称相同的成员而采用作用域的方式进行区分。
如：A,B表示两个类，在A,B中都有成员member。那么
A::member就表示类A中的成员member，B::member就表示类B中的成员member。

- 全局作用域符号：当全局变量在局部函数中与其中某个变量重名，那么就可以用::来区分，如：
```c++
charzhou; //全局变量
voidsleep()
{
    charzhou; //局部变量
    char(局部变量) = char(局部变量) *char(局部变量) ;
    ::char(全局变量) =::char(全局变量) *char(局部变量);
}
```
- ::是C++里的“作用域分解运算符”。
比如声明了一个类A，类A里声明了一个成员函数voidf()，但没有在类的声明里给出f的定义，那么在类外定义f时，就要写成voidA::f()，表示这个f()函数是类A的成员函数。例如

```c++
classCA {
public: 
  intca_var;  
  intadd(inta, intb);  
  intadd(inta);  
};
   
//那么在实现这个函数时，必须这样书写： 
intCA::add(inta, intb)  
{
  returna + b;  
}
   
//另外，双冒号也常常用于在类变量内部作为当前类实例的元素进行表示，比如: 
intCA::add(inta)  
{ 
  returna + ::ca_var;  
}
//表示当前类实例中的变量ca_var。
```
#### 常量
##### 定义常量
在 C++ 中，有两种简单的定义常量的方式：
- 使用 `#define` 预处理器。
- 使用 `const` 关键字。
- 请注意，把常量定义为大写字母形式，是一个很好的编程实践
```c++
const int A=10;       //正确。
const int A;          //错误，没有赋初始值。
extern const int A;   //正确，使用extern的外部变量。
```
##### const char*, char const*, char*const 的区别

Bjarne在他的The C++ Programming Language里面给出过一个助记的方法：**把一个声明从右向左读**
```c++
char * const cp; //( * 读成 pointer to ) 
cp is a const pointer to char 

const char * p; 
p is a pointer to const char; 

char const * p; //const关键字放在类型或变量名之前等价的。
p is a pointer to const char;
```
```c++
const int n=5;    //same as below
int const m=10;

const int *p;    //same as below  const (int) * p
int const *q;    // (int) const *p


char ** p1; 
//    pointer to    pointer to    char 
const char **p2;
//    pointer to    pointer to const char 
char * const * p3;
//    pointer to const pointer to    char 
const char * const * p4;
//    pointer to const pointer to const char 
char ** const p5;
// const pointer to    pointer to    char 
const char ** const p6;
// const pointer to    pointer to const char 
char * const * const p7;
// const pointer to const pointer to    char 
const char * const * const p8;
// const pointer to const pointer to const char
```
##### 宏定义 #define 和常量 const 的区别
- 类型和安全检查不同
  - 宏定义是字符替换，没有数据类型的区别，同时这种替换没有类型安全检查，可能产生边际效应等错误；
  - const常量是常量的声明，有类型区别，需要在编译阶段进行类型检查
- 编译器处理不同
  - 宏定义是一个"编译时"概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束与编译时期；
  - const常量是一个"运行时"概念，在程序运行使用，类似于一个只读行数据
- 存储方式不同
  - 宏定义是直接替换，不会分配内存，存储与程序的代码段中；
  - const常量需要进行内存分配，存储与程序的数据段中
-   定义域不同
```c++
void f1 ()
{
    #define N 12
    const int n 12;
}
void f2 ()
{
    cout<<N <<endl; //正确，N已经定义过，不受定义域限制
    cout<<n <<endl; //错误，n定义域只在f1函数中
}
```
- 定义后能否取消
    - 宏定义可以通过#undef来使之前的宏定义失效
    - const常量定义后将在定义域内永久有效
```c++
void f1()
{
  #define N 12
  const int n = 12;

  #undef N //取消宏定义后，即使在f1函数中，N也无效了
  #define N 21//取消后可以重新定义
}
```
- 是否可以做函数参数
  - 宏定义不能作为参数传递给函数
  - const常量可以在函数的参数列表中出现
##### 字符串常量
下面这三种形式所显示的字符串是相同的。
```
"hello, dear"

"hello, \

dear"

"hello, " "d" "ear"
```
##### 布尔常量
布尔常量共有两个，它们都是标准的 C++ 关键字：
- true 值代表真。
- false 值代表假。
我们不应把 true 的值看成 1，把 false 的值看成 0。
##### 字符常量
```
转义序列	含义
\\	\ 字符
\'	' 字符
\"	" 字符
\?	? 字符
\a	警报铃声
\b	退格键
\f	换页符
\n	换行符
\r	回车
\t	水平制表符
\v	垂直制表符
```